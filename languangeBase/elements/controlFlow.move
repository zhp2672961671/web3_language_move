/*
控制流
通过控制流表达式，我们可以选择运行某个代码块，或者跳过某段代码而运行另一个代码块。
Move 支持 if 表达式和循环表达式。
*/
/*
if 表达式
if 表达式允许我们在条件为真时运行代码块，在条件为假时运行另一个代码块。
*/
/*
这个例子中，当a == true时打印0，当a是false时打印99，语法非常简单：
if (<布尔表达式>) <表达式> else <表达式>;
*/
script{
    use 0x1::Debug;
    fun main(){
        let a=true;
        if(a){
            Debug::print<u8>(&0);
        }else{
            Debug::print<u8>(&99);
        };
    }
}
/*
if是一个表达式，我们可以在 let 声明中使用它。但是像所有其他表达式一样，它必须以分号结尾。
现在，b 将根据 a 表达式为变量分配不同的值。但是 if 的两个分支必须返回相同的类型！否则，变量 b 将会具有不同类型，这在静态类型的语言中是不允许的。
在编译器术语中，这称为分支兼容性 —— 两个分支必须返回兼容（相同）类型。
*/
script{
    use 0x1::Debug;
    fun main(){
        //尝试切换到false
        let a= true;
        let b=if(a){//第一分支
            10
        }else{//第二分支
            20
        };
        Debug::print<u8>(&b);
    }
}
/*
if 不一定非要和 else 一起使用，也可以单独使用。
但是请记住，不能在 let 赋值语句中使用不带分支的表达式！因为如果 if 不满足条件，就会导致变量未被定义，这同样是不允许的。
*/
script{
    use 0x1::Debug;
    fun mian(){
        let a=true;
        //只有一个可选分支
        // 如果a=false，则不会调用debug
        if(a){
            Debug::print<u8>(&10);
        };
    }
}
/*
循环表达式
在 Move 中定义循环有两种方法：
while 条件循环
loop 无限循环
*/
/*
while 条件循环
while 是定义循环的一种方法：在条件为真时执行表达式。只要条件为 true，代码将一遍又一遍的执行。条件通常使用外部变量或计数器实现。
需要指出的是，while 表达式就像 if 表达式一样，也需要使用分号结束。while 循环的通用语法是：
while (<布尔表达式>) <表达式>;
与 if 表达式不同的是，while 表达式没有返回值，因而也就不能像 if 那样把自己赋值给某变量
*/
script{
    fun main(){
        let i =0;//定义计数器
        //i＜5时迭代
        //每次迭代增加i
        //当i为5时，条件失败，循环退出
        while(i < 5){
            i=i+1;
        };
    }
}
/*
无法访问的代码
安全是 Move 最显著的特性。出于安全考虑，Move 规定所有变量必须被使用。并且出于同样的原因，Move 禁止使用无法访问的代码。由于数字资产是可编程的，
因此可以在代码中使用它们（我们将在 Resource 一章中对其进行介绍）。
而将资产放置在无法访问的代码中可能会带来问题，并造成损失。
这就是为什么无法访问的代码如此重要的原因。
*/
/*
无限循环
Move 提供了一种定义无限循环的方法，它没有条件判断，会一直执行。一旦执行该代码将消耗所有给定资源（交易费），
大多数情况下，编译器也无法判断循环是否是无限的，也就无法阻止无限循环代码的发布。
因此，使用无限循环时一定要注意安全，通常情况下建议使用 while 条件循环。
无限循环用关键字 loop 定义。
*/

