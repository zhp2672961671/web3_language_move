/*
在编程语言中，表达式是具有返回值的代码单元。
有返回值的函数调用是一个表达式，它有返回值；整型常数也是一个表达式，它返回整数；
其它表达式依此类推。
表达式必须用分号";"隔开
*/
/*
小结
我们来总结一下本章要点：
每个表达式都必须以分号结尾，除非它是 block 的返回值。
关键字 let 使用值或表达式创建新变量，该变量的生命周期与其作用域相同。
代码块是一个可能具有也可能没有返回值的表达式。
*/

/*
空表达式
类似于 Rust，Move 中的空表达式用空括号表示：
*/
script {
    fun empty(){
        ()//这是一个空表达式
    }
}
/*
文字（Literal）表达式
下面的代码，每行包含一个以分号结尾的表达式。最后一行包含三个表达式，由分号隔开。
*/
script{
    fun main(){
        10;
        10+5;
        true;
        true!=false;
        0x1;
        1;2;3
    }
}
/*
变量和let关键字
关键字 let 用来将表达式的值存储在变量中，以便于将其传递到其它地方。
我们曾经在基本类型章节中使用过 let，它用来创建一个新变量，该变量要么为空（未定义），要么为某表达式的值。
关键字 let 会在当前作用域内创建新变量，并可以选择初始化此变量。该表达式的语法是：let : ;或let = 。
创建和初始化变量后，就可以使用变量名来修改或访问它所代表的值了。在上面的示例中，变量 a 在函数末尾被初始化，并被分配了一个值 c。
等号"="是赋值运算符。它将右侧表达式赋值给左侧变量。示例：a = 10 表示将整数10赋值给变量a。
*/
script {
    fun main(){
        let a;
        let b=true;
        let c=10;
        let d =0x1;
        a=c;
    }
}
/*
整型运算符
Move具有多种用于修改整数值的运算符：

运算符	操作	类型
+	sum	uint	LHS加上RHS
-	sub	uint	从LHS减去RHS
/	div	uint	用LHS除以RHS
*	mul	uint	LHS乘以RHS
%	mod	uint	LHS除以RHS的余数
<<	lshift	uint	LHS左移RHS位
>>	rshift	uint	LHS右移RHS位
&	and	uint	按位与
^	xor	uint	按位异或
\	or	uint	按位或

*/
/*
下划线 "_" 表示未被使用
Move 中每个变量都必须被使用，否则代码编译不会通过, 因此我们不能初始化一个变量却不去使用它。但是你可以用下划线来告诉编译器，这个变量是故意不被使用的。
*/
// 例如，下面的脚本在编译时会报错：
script{
    fun main(){
        let a=1;
    }
}
// 报错:
//     ┌── /scripts/script.move:3:13 ───
//     │
//  33 │         let a = 1;
//     │             ^ Unused assignment or binding for local 'a'. Consider removing or replacing it with '_'
//     │

// 编译器给出明确提示：用下划线来代替变量名。
script{
    fun main(){
        let _=1;
    }
}
/*
屏蔽
Move 允许两次定义同一个的变量，第一个变量将会被屏蔽。但有一个要求：我们仍然需要"使用"被屏蔽的变量。
*/
script{
    fun main(){
        let a=1;
        let a=2;
        let _=a;
    }
}
/*
在上面的示例中，我们仅使用了第二个a。第一个a实际上未使用，因为a在下一行被重新定义了。所以，我们可以通过下面的修改使得这段代码正常运行。
*/
script{
    fun main(){
        let a=1;
        let a=a+2;
        let _=a;
    }
}
/*
块表达式
块表达式用花括号"{}"表示。块可以包含其它表达式（和其它代码块）。函数体在某种意义上也是一个代码块。
*/
script{
    fun block(){
        {};
        {{};};
        true;
        {
            true;
            {10;};
        };
        {{{10;};};};
    }
}
/*
作用域
如 Wikipedia 中所述，作用域是绑定生效的代码区域。换句话说，变量存在于作用域中。Move 作用域是由花括号扩起来的代码块，它本质上是一个块。
定义一个代码块，实际上是定义一个作用域。
从该示例可以看出，作用域是由代码块（或函数）定义的。它们可以嵌套，并且可以定义多个作用域，数量没有限制。
*/
script{
    fun scope_sample(){
        //这是一个空表达式这是函数范围
        {
            //这是函数范围内的块范围
            {
                //这是范围内的范围
                //在函数范围内。。。等
            };
        };
        [
            //这是函数范围内的另一个块
        ];
    }
}
/*
变量的生命周期和可见性
我们前面已经介绍过关键字 let 的作用，它可以用来定义变量。有一点需要强调的是，该变量仅存在于变量所处的作用域内。
也就是说，它在作用域之外不可访问，并在作用域结束后立即消亡
*/
script{
    fun let_scope_sample(){
        let a=1;//我们在函数范围内定义了变量A
        {
            let b=2;//我们在函数范围内定义了变量A变量B在块范围内
            {// 变量A和B可在内部访问
            // 嵌套的作用域
            let c=a+b;
            };//在这里C死了
            // 我们不能写这行
            // let d = c + b;
            // 变量C随其作用域而消亡
            // 但我们可以定义另一个C
            let c =b-1;
        };// 变量C失效，C也失效
        // 这是不可能的
        // let d = b + c;
        // 我们可以定义任何我们想要的变量
        let b =a+1;
        let c =b+1;
    };//函数作用域结束-a、b和c被删除，不再可访问
// 变量仅存在于其作用域（或代码块）内，当作用域结束时变量随之消亡。
}
/*
块返回值
上面我们了解到代码块是一个表达式，但是我们没有介绍为什么它是一个表达式以及代码块的返回值是什么。
代码块可以返回一个值，如果它后面没有分号，则返回值为代码块内最后一个表达式的值。
听起来不好理解，我们来看下面的例子：
*/
script{
    fun block_ret_sample(){
        //由于block是一个表达式，我们可以使用let将它的值赋给变量
        let a={
            let c=10;
            c*100//没有分号！
        };//作用域结束，变量a的值为10000
        let b={
            a*1000//没有半成品！
        };
        // 变量b的值为10000000
        {
            10;//没有半成品！
        };//此块不返回值
        let _=a+b;//a和b都从块中获取值
    }
}